===== app/_layout.tsx =====
import { AuthProvider } from '@/context/AuthContext';
import { Stack } from 'expo-router';

export default function RootLayout() {
  return (
    <AuthProvider>
      <Stack screenOptions={{ headerShown: false, animation: 'fade' }}>
        {/* Only these two should be here */}
        <Stack.Screen name="(app)" options={{animation: 'fade'}} />
        <Stack.Screen name="(auth)" />
      </Stack>
    </AuthProvider>
  );
}

===== app/(app)/_layout.tsx =====
import { Stack } from "expo-router";

export default function MainLayout() {

  return (
    <Stack screenOptions={{ headerShown: false , animation: 'fade'}}>
      <Stack.Screen name="home" />
      <Stack.Screen name="profile" options={{animation:"fade_from_bottom"}} />
      <Stack.Screen name="create" options={{animation:"fade_from_bottom"}} />
      <Stack.Screen name="edit/[id]" options={{animation:"fade_from_bottom"}} />
      <Stack.Screen name="search" options={{animation:"fade_from_bottom"}} />
    </Stack>
  );
}

===== app/(app)/create.tsx =====
import Button from '@/components/Button';
import Header from '@/components/Header';
import Input from '@/components/Input';
import ScreenWrapper from '@/components/ScreenWrapper';
import TextArea from '@/components/TextArea';
import Typo from '@/components/Typo';
import { colors, HEADER_HEIGHT, radius, spacingX, spacingY } from '@/constants/theme';
import api from '@/services/api';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import { Alert, KeyboardAvoidingView, Platform, ScrollView, StyleSheet, View } from 'react-native';

export default function CreateScreen() {
  const [title, setTitle] = useState('');
  const [link, setLink] = useState('');
  const [description, setDescription] = useState('');
  const [tags, setTags] = useState('');
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  const handleSave = async () => {
    if (!title && !link) return Alert.alert('Error', 'Please provide a title or link.');
    setLoading(true);
    try {
      const tagArray = tags.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
      await api.post('/content', { title, link, description, tags: tagArray });
      router.back();
    } catch (e) {
      Alert.alert('Error', 'Could not save recall item');
    } finally {
      setLoading(false);
    }
  };

  return (
    <ScreenWrapper>
      <Header title="Add to Brain" />
      <KeyboardAvoidingView 
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 10 : 0}
      >
        <ScrollView contentContainerStyle={styles.scrollContent} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
          <View style={styles.card}>
              <Typo size={14} color={colors.neutral400} style={styles.label}>Title</Typo>
              <Input placeholder="e.g. React Tutorial" value={title} onChangeText={setTitle} containerStyle={styles.spacer} />

              <Typo size={14} color={colors.neutral400} style={styles.label}>Link (Optional)</Typo>
              <Input placeholder="https://..." value={link} onChangeText={setLink} containerStyle={styles.spacer} />

              <Typo size={14} color={colors.neutral400} style={styles.label}>Description</Typo>
              <TextArea placeholder="Add some details..." value={description} onChangeText={setDescription} containerStyle={styles.spacer} />

              <Typo size={14} color={colors.neutral400} style={styles.label}>Tags</Typo>
              <Input placeholder="tech, ideas, recipes" value={tags} onChangeText={setTags} containerStyle={styles.spacer} />

              <Button onPress={handleSave} loading={loading} style={styles.button}>
                  <Typo color={colors.white} fontWeight="bold">Save Memory</Typo>
              </Button>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </ScreenWrapper>
  );
}

const styles = StyleSheet.create({
  scrollContent: { paddingHorizontal: spacingX._10, paddingTop: HEADER_HEIGHT, paddingBottom: 50 },
  card: {
    backgroundColor: colors.darkCard, 
    borderRadius: radius._30,
    padding: spacingX._20,
    shadowColor: '#000', shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.3, shadowRadius: 10, elevation: 4,
  },
  label: { marginBottom: spacingY._5, marginLeft: 5, fontWeight: '600' },
  spacer: { marginBottom: spacingY._15 },
  button: { marginTop: spacingY._10 },
});

===== app/(app)/edit/[id].tsx =====
import Button from '@/components/Button';
import Header from '@/components/Header';
import Input from '@/components/Input';
import Loading from '@/components/Loading';
import ScreenWrapper from '@/components/ScreenWrapper';
import TextArea from '@/components/TextArea';
import Typo from '@/components/Typo';
import { colors, HEADER_HEIGHT, radius, spacingX, spacingY } from '@/constants/theme';
import api from '@/services/api';
import { useLocalSearchParams, useRouter } from 'expo-router';
import React, { useEffect, useState } from 'react';
import { Alert, KeyboardAvoidingView, Platform, ScrollView, StyleSheet, View } from 'react-native';

export default function EditScreen() {
  const { id } = useLocalSearchParams();
  const router = useRouter();
  
  const [title, setTitle] = useState('');
  const [link, setLink] = useState('');
  const [description, setDescription] = useState('');
  const [tags, setTags] = useState('');
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);

  useEffect(() => { fetchContent(); }, [id]);

  const fetchContent = async () => {
    try {
      const res = await api.get(`/content/recall/${id}`);
      const data = res.data.content;
      setTitle(data.title || '');
      setLink(data.link || '');
      setDescription(data.description || '');
      if (data.tags && Array.isArray(data.tags)) setTags(data.tags.join(', '));
    } catch (e) {
      Alert.alert('Error', 'Could not fetch content details');
      router.back();
    } finally {
      setLoading(false);
    }
  };

  const handleUpdate = async () => {
    setSaving(true);
    try {
      const tagArray = tags.split(',').map(t => t.trim()).filter(t => t !== '');
      await api.put(`/content/recall/${id}`, { title, link, description, tags: tagArray.length > 0 ? tagArray : undefined });
      router.back();
    } catch (e) {
      Alert.alert('Error', 'Could not update item');
    } finally {
      setLoading(false);
    }
  };

  if (loading) return <ScreenWrapper><Loading /></ScreenWrapper>;

  return (
    <ScreenWrapper>
      <Header title="Edit Brain Item" />
      
      {/* ADDED KEYBOARD HANDLING */}
      <KeyboardAvoidingView 
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 10 : 0}
      >
        <ScrollView 
            contentContainerStyle={styles.container} 
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
        >
            <View style={styles.card}>
                <Typo size={14} color={colors.neutral400} style={styles.label}>Title</Typo>
                <Input value={title} onChangeText={setTitle} containerStyle={styles.spacer} />

                <Typo size={14} color={colors.neutral400} style={styles.label}>Link</Typo>
                <Input value={link} onChangeText={setLink} containerStyle={styles.spacer} />

                <Typo size={14} color={colors.neutral400} style={styles.label}>Description</Typo>
                <TextArea value={description} onChangeText={setDescription} containerStyle={styles.spacer} />

                <Typo size={14} color={colors.neutral400} style={styles.label}>Add New Tags</Typo>
                <Input placeholder="react, tech" value={tags} onChangeText={setTags} containerStyle={styles.spacer} />

                <Button onPress={handleUpdate} loading={saving} style={styles.button}>
                <Typo color={colors.white} fontWeight="bold">Update</Typo>
                </Button>
            </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </ScreenWrapper>
  );
}

const styles = StyleSheet.create({
  container: { paddingHorizontal: spacingX._20, paddingTop: HEADER_HEIGHT, paddingBottom: 50 },
  card: {
    backgroundColor: colors.darkCard, 
    borderRadius: radius._30,
    padding: spacingX._20,
    shadowColor: '#000', shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.3, shadowRadius: 10, elevation: 4,
  },
  label: { marginBottom: spacingY._5, marginLeft: 5, fontWeight: '600' },
  spacer: { marginBottom: spacingY._15 },
  button: { marginTop: spacingY._20 },
});

===== app/(app)/home.tsx =====
import ScreenWrapper from '@/components/ScreenWrapper';
import SkeletonCard from '@/components/SkeletonCard';
import Typo from '@/components/Typo';
import { colors, radius, spacingX, spacingY } from '@/constants/theme';
import api from '@/services/api';
import { useFocusEffect } from '@react-navigation/native';
import { useRouter } from 'expo-router';
import { getLinkPreview } from 'link-preview-js';
import { ArrowUpRight, MagnifyingGlass, PencilSimple, Play, Plus, Trash, UserCircle } from 'phosphor-react-native';
import React, { useCallback, useEffect, useState } from 'react';
import { FlatList, Image, Linking, Platform, RefreshControl, StatusBar, StyleSheet, TouchableOpacity, View } from 'react-native';

// --- HELPER: YouTube ID ---
const getYoutubeId = (url: string) => {
  if (!url) return null;
  const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
  const match = url.match(regExp);
  return (match && match[2].length === 11) ? match[2] : null;
};

// --- COMPONENT: Smart Preview ---
const SmartPreview = ({ url }: { url: string }) => {
  const [imageUrl, setImageUrl] = useState<string | null>(null);
  const [isVideo, setIsVideo] = useState(false);

  useEffect(() => {
    let isMounted = true;
    const fetchPreview = async () => {
      if (!url) return;
      const ytId = getYoutubeId(url);
      if (ytId) {
        if (isMounted) {
          setImageUrl(`https://img.youtube.com/vi/${ytId}/hqdefault.jpg`);
          setIsVideo(true);
        }
        return;
      }
      if (url.includes('instagram.com/p/')) {
        const cleanUrl = url.split('?')[0].replace(/\/$/, ""); 
        if (isMounted) setImageUrl(`${cleanUrl}/media/?size=l`);
        return;
      }
      try {
        const data: any = await getLinkPreview(url);
        if (isMounted && data.images && data.images.length > 0) {
          setImageUrl(data.images[0]);
        }
      } catch (e) {
        console.log("No preview found for:", url);
      }
    };
    fetchPreview();
    return () => { isMounted = false; };
  }, [url]);

  if (!imageUrl) return null;

  return (
    <View style={styles.previewContainer}>
      <Image source={{ uri: imageUrl }} style={styles.previewImage} resizeMode="cover" />
      {isVideo && (
        <View style={styles.playIconOverlay}>
          <View style={styles.playCircle}>
             <Play weight="fill" color={colors.black} size={20} style={{marginLeft: 2}} />
          </View>
        </View>
      )}
    </View>
  );
};

export default function HomeScreen() {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  const fetchRecalls = async () => {
    try {
      const res = await api.get('/content');
      setData(res.data.content);
    } catch (e) {
      console.error(e);
    } finally {
      setLoading(false);
    }
  };

  useFocusEffect(
    useCallback(() => {
      fetchRecalls();
    }, [])
  );

  const deleteRecall = async (id: string) => {
    try {
      await api.delete('/content', { data: { contentId: id } });
      setData(data.filter((item: any) => item._id !== id));
    } catch (e) {
      console.error('Failed to delete', e);
    }
  };

  const HomeHeader = () => (
    <View style={styles.headerContainer}>
      <View style={styles.headerTopRow}>
        <TouchableOpacity style={styles.iconButton} onPress={() => router.push('/(app)/search')}>
          <MagnifyingGlass color={colors.white} size={28} weight="bold" />
        </TouchableOpacity>
        <TouchableOpacity onPress={() => router.push('/(app)/profile')}>
          <UserCircle color={colors.white} size={32} weight="fill" />
        </TouchableOpacity>
      </View>
      <View style={styles.headerTitleRow}>
        <Typo size={32} fontWeight="bold" color={colors.white}>My Brain</Typo>
        <Typo size={16} color={colors.neutral200} style={{ marginTop: 5 }}>Your digital memory bank</Typo>
      </View>
    </View>
  );

  const getCardStyle = (index: number) => {
    const styles = [
      { bg: '#FDE047', text: colors.black, actionBtn: colors.black, actionIcon: colors.white, pillBg: 'rgba(0,0,0,0.08)', pillText: '#333' },
      { bg: colors.white, text: colors.black, actionBtn: colors.black, actionIcon: colors.white, pillBg: '#f3f4f6', pillText: colors.black },
      { bg: '#bef264', text: colors.black, actionBtn: '#1a2e05', actionIcon: '#d9f99d', pillBg: 'rgba(26, 46, 5, 0.1)', pillText: '#1a2e05' },
      { bg: '#fecdd3', text: colors.black, actionBtn: '#881337', actionIcon: '#ffe4e6', pillBg: 'rgba(136, 19, 55, 0.1)', pillText: '#881337' },
    ];
    return styles[index % styles.length];
  };

  const renderItem = ({ item, index }: { item: any, index: number }) => {
    const theme = getCardStyle(index);
    return (
      <View style={[styles.card, { backgroundColor: theme.bg }]}>
        <View style={styles.cardTop}>
          <View style={styles.textContainer}>
            <Typo fontWeight="700" size={20} color={theme.text} style={{ lineHeight: 28 }}>
              {item.title || 'Untitled Note'}
            </Typo>
            {item.description && (
              <Typo size={15} color={theme.text} style={{ marginTop: 8, opacity: 0.7 }}>
                {item.description}
              </Typo>
            )}
          </View>
          {item.link ? (
            <TouchableOpacity 
              style={[styles.bigActionButton, { backgroundColor: theme.actionBtn }]}
              onPress={() => Linking.openURL(item.link)}
            >
              <ArrowUpRight color={theme.actionIcon} size={24} weight="bold" />
            </TouchableOpacity>
          ) : <View style={{ width: 50 }} />}
        </View>

        {item.link && (
            <TouchableOpacity onPress={() => Linking.openURL(item.link)} activeOpacity={0.9}>
                <SmartPreview url={item.link} />
            </TouchableOpacity>
        )}

        <View style={styles.cardBottom}>
           <TouchableOpacity 
             style={[styles.pillButton, { backgroundColor: theme.pillBg }]}
             onPress={() => router.push(`/(app)/edit/${item._id}`)}
           >
              <PencilSimple size={16} weight="bold" color={theme.pillText} />
              <Typo size={13} fontWeight="600" color={theme.pillText} style={{ marginLeft: 6 }}>Edit</Typo>
           </TouchableOpacity>

           <TouchableOpacity 
             style={[styles.pillButton, { backgroundColor: theme.pillBg }]}
             onPress={() => deleteRecall(item._id)}
           >
              <Trash size={16} weight="bold" color={theme.pillText} />
              <Typo size={13} fontWeight="600" color={theme.pillText} style={{ marginLeft: 6 }}>Delete</Typo>
           </TouchableOpacity>
        </View>
      </View>
    );
  };

  return (
    <ScreenWrapper style={{ paddingTop: 0 }}>
      <StatusBar barStyle="light-content" backgroundColor="transparent" translucent={true} />
      
      {loading ? (
        // Show Skeletons while loading
        <FlatList
          data={[1,2,3,4,5]} // Dummy data for skeletons
          keyExtractor={(item) => item.toString()}
          renderItem={() => <SkeletonCard />} // Render the skeleton
          contentContainerStyle={styles.list}
        />
      ) : (
        // Show Real Data when done
        <FlatList
          data={data}
          keyExtractor={(item) => item._id}
          renderItem={renderItem}
          contentContainerStyle={styles.list}
          refreshControl={
            <RefreshControl 
               refreshing={loading} 
               onRefresh={fetchRecalls} 
               tintColor={colors.primary} 
               progressViewOffset={260} 
            />
          }
          ListEmptyComponent={
            <Typo style={{ textAlign: 'center', marginTop: 40 }} color={colors.neutral400}>No memories found.</Typo>
          }
        />
      )}

      <HomeHeader />

      <TouchableOpacity style={styles.fab} onPress={() => router.push('/(app)/create')}>
        <Plus color={colors.white} size={30} weight="bold" />
      </TouchableOpacity>
    </ScreenWrapper>
  );
}

const styles = StyleSheet.create({
  headerContainer: {
    backgroundColor: '#E64A19',
    paddingTop: Platform.OS === 'ios' ? 60 : 50,
    paddingBottom: spacingY._25,
    paddingHorizontal: spacingX._20,
    borderBottomLeftRadius: radius._40,
    borderBottomRightRadius: radius._40,
    zIndex: 10,
    position: 'absolute',
    top: 0, left: 0, right: 0,
  },
  headerTopRow: { flexDirection: 'row', justifyContent: 'space-between', marginBottom: spacingY._20 },
  headerTitleRow: { paddingBottom: 10 },
  iconButton: { padding: 5 },
  list: { 
      paddingHorizontal: spacingX._5, 
      paddingTop: 250, // Ensure content starts below header
      flexGrow: 1, 
      gap: spacingY._5, 
      paddingBottom: 100 
  },
  card: {
    borderRadius: radius._50,
    padding: 22,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.05,
    shadowRadius: 10,
    elevation: 3,
  },
  cardTop: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'flex-start' },
  textContainer: { flex: 1, paddingRight: 15 },
  bigActionButton: { width: 52, height: 52, borderRadius: 26, justifyContent: 'center', alignItems: 'center' },
  previewContainer: {
    marginTop: 20, width: '100%', height: 180, borderRadius: 20, overflow: 'hidden', backgroundColor: 'rgba(0,0,0,0.05)', borderWidth: 1, borderColor: 'rgba(0,0,0,0.05)'
  },
  previewImage: { width: '100%', height: '100%' },
  playIconOverlay: {
    position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0,0,0,0.1)'
  },
  playCircle: {
    width: 50, height: 50, borderRadius: 25, backgroundColor: 'rgba(255,255,255,0.9)', justifyContent: 'center', alignItems: 'center', elevation: 5
  },
  cardBottom: { flexDirection: 'row', marginTop: 20, gap: 10 },
  pillButton: { flexDirection: 'row', alignItems: 'center', paddingVertical: 10, paddingHorizontal: 16, borderRadius: 20 },
  fab: {
    position: 'absolute', bottom: 30, right: 20, backgroundColor: '#111', width: 65, height: 65, borderRadius: 35, justifyContent: 'center', alignItems: 'center', elevation: 10,
  },
});

===== app/(app)/profile.tsx =====
import Button from '@/components/Button';
import Header from '@/components/Header';
import ScreenWrapper from '@/components/ScreenWrapper';
import Typo from '@/components/Typo';
import { colors, HEADER_HEIGHT, radius, spacingX, spacingY } from '@/constants/theme';
import { useAuth } from '@/context/AuthContext';
import api from '@/services/api';
import { SignOut } from 'phosphor-react-native';
import React, { useEffect, useState } from 'react';
import { Alert, StyleSheet, TouchableOpacity, View } from 'react-native';

export default function ProfileScreen() {
  const { signOut } = useAuth();
  const [shareLink, setShareLink] = useState<string | null>(null);

  useEffect(() => { fetchShareStatus(); }, []);

  const fetchShareStatus = async () => {
    try {
      const res = await api.get('/content/share');
      if (res.data.link) setShareLink(res.data.link.hash);
    } catch (e) {}
  };

  const toggleShareLink = async () => {
    try {
      if (shareLink) {
        await api.post('/content/share', { share: false });
        setShareLink(null);
      } else {
        const res = await api.post('/content/share', { share: true });
        setShareLink(res.data.link.hash);
      }
    } catch (e) { Alert.alert('Error', 'Could not update link'); }
  };

  return (
    <ScreenWrapper>
      <Header title="Settings" />
      
      <View style={styles.container}>
        
        {/* Public Link Card */}
        <View style={styles.card}>
          <Typo fontWeight="bold" size={18} color={colors.textLight} style={styles.sectionTitle}>
            Public Brain Link
          </Typo>
          <Typo size={14} color={colors.neutral400} style={{ marginBottom: 15 }}>
            {shareLink ? `Your brain is public!` : 'Your brain is currently private.'}
          </Typo>
          <Button 
            onPress={toggleShareLink} 
            style={{ backgroundColor: shareLink ? colors.rose : colors.primary, borderRadius: radius._15 }}
          >
            <Typo color={colors.white} fontWeight="bold">
              {shareLink ? 'Disable Public Link' : 'Generate Public Link'}
            </Typo>
          </Button>
        </View>

        {/* Logout Button */}
        <TouchableOpacity style={styles.logoutBtn} onPress={signOut}>
          <SignOut color={colors.rose} size={24} weight="bold" />
          <Typo color={colors.rose} fontWeight="bold" style={{ marginLeft: 10 }}>Log Out</Typo>
        </TouchableOpacity>

      </View>
    </ScreenWrapper>
  );
}

const styles = StyleSheet.create({
  container: { paddingHorizontal: spacingX._20, paddingTop: HEADER_HEIGHT },
  card: { 
    backgroundColor: colors.darkCard, 
    padding: spacingX._20, 
    borderRadius: radius._30, 
    marginBottom: spacingY._20, 
    shadowColor: '#000', 
    shadowOpacity: 0.3, 
    shadowRadius: 10, 
    elevation: 4 
  },
  sectionTitle: { marginBottom: spacingY._15 },
  logoutBtn: { 
    flexDirection: 'row', 
    alignItems: 'center', 
    justifyContent: 'center', 
    padding: spacingY._15, 
    marginTop: 10 
  }
});

===== app/(app)/search.tsx =====
import Header from '@/components/Header';
import Input from '@/components/Input';
import ScreenWrapper from '@/components/ScreenWrapper';
import Typo from '@/components/Typo';
import { colors, HEADER_HEIGHT_EXPANDED, radius, spacingX, spacingY } from '@/constants/theme';
import api from '@/services/api';
import { ArrowUpRight, MagnifyingGlass, Trash } from 'phosphor-react-native';
import React, { useEffect, useRef, useState } from 'react';
import { ActivityIndicator, FlatList, Linking, StyleSheet, TextInput, TouchableOpacity, View } from 'react-native';

export default function SearchScreen() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  
  // 1. Create a ref for the input
  const inputRef = useRef<TextInput>(null);

  // 2. Focus the input when the component mounts
  useEffect(() => {
    const timer = setTimeout(() => {
      inputRef.current?.focus();
    }, 100); // 100ms delay ensures smooth transition
    return () => clearTimeout(timer);
  }, []);

  const handleSearch = async () => {
    if (!query.trim()) return;
    setLoading(true);
    try {
      const res = await api.get(`/content/search?q=${query}`);
      setResults(res.data.results);
    } catch (e) {
      console.error('Search failed', e);
    } finally {
      setLoading(false);
    }
  };

  const clearSearch = () => {
    setQuery('');
    setResults([]);
    // Optional: Focus again after clearing
    inputRef.current?.focus();
  };

  const getCardStyle = (index: number) => {
    const styles = [
      { bg: '#FDE047', text: colors.black, actionBtn: colors.black, actionIcon: colors.white },
      { bg: colors.white, text: colors.black, actionBtn: colors.black, actionIcon: colors.white },
      { bg: '#bef264', text: colors.black, actionBtn: '#1a2e05', actionIcon: '#d9f99d' },
      { bg: '#fecdd3', text: colors.black, actionBtn: '#881337', actionIcon: '#ffe4e6' },
    ];
    return styles[index % styles.length];
  };

  const renderItem = ({ item, index }: { item: any, index: number }) => {
    const theme = getCardStyle(index);
    return (
      <View style={[styles.card, { backgroundColor: theme.bg }]}>
        <View style={styles.cardTop}>
          <View style={styles.textContainer}>
            <Typo fontWeight="700" size={20} color={theme.text} style={{ lineHeight: 28 }}>{item.title}</Typo>
            {item.description && (
              <Typo size={15} color={theme.text} style={{ marginTop: 8, opacity: 0.7 }}>{item.description}</Typo>
            )}
          </View>
          {item.link ? (
            <TouchableOpacity style={[styles.bigActionButton, { backgroundColor: theme.actionBtn }]} onPress={() => Linking.openURL(item.link)}>
              <ArrowUpRight color={theme.actionIcon} size={24} weight="bold" />
            </TouchableOpacity>
          ) : <View style={{ width: 50 }} />}
        </View>
      </View>
    );
  };

  return (
    <ScreenWrapper style={{ paddingTop: 0 }}>
      <Header title="Search Brain">
        <View style={styles.searchContainer}>
          <Input 
            // 3. Attach the ref here
            inputRef={inputRef}
            placeholder="Search..." 
            value={query} 
            onChangeText={setQuery} 
            // OVERRIDE: White input on orange header
            containerStyle={styles.searchInput} 
            inputStyle={{ color: colors.text }} 
            placeholderTextColor={colors.neutral400}
            onSubmitEditing={handleSearch}
            icon={query.length > 0 ? (
                <TouchableOpacity onPress={clearSearch}>
                   <Trash size={20} color={colors.neutral400} weight="fill" />
                </TouchableOpacity>
              ) : undefined}
          />
          <TouchableOpacity onPress={handleSearch} style={styles.headerSearchBtn}>
             <MagnifyingGlass color={colors.primary} size={22} weight="bold" />
          </TouchableOpacity>
        </View>
      </Header>
      
      {loading ? (
        <ActivityIndicator size="large" color={colors.primary} style={{ marginTop: HEADER_HEIGHT_EXPANDED + 50 }} />
      ) : (
        <FlatList
          data={results}
          keyExtractor={(item) => item._id}
          renderItem={renderItem}
          contentContainerStyle={styles.list}
          ListEmptyComponent={<Typo style={{ textAlign: 'center', marginTop: 100 }} color={colors.neutral400}>{query ? 'No results found.' : 'Type to search your brain.'}</Typo>}
        />
      )}
    </ScreenWrapper>
  );
}

const styles = StyleSheet.create({
  list: { paddingHorizontal: spacingX._5, paddingTop: HEADER_HEIGHT_EXPANDED + 30, flexGrow: 1, gap: spacingY._5 },
  searchContainer: { flexDirection: 'row', alignItems: 'center', gap: 10 },
  searchInput: { 
    flex: 1, 
    height: 52, 
    backgroundColor: colors.white, 
    borderColor: colors.white,
    paddingHorizontal: 12
  },
  headerSearchBtn: { backgroundColor: colors.white, height: 52, width: 52, borderRadius: radius.full, alignItems: 'center', justifyContent: 'center' },
  card: { borderRadius: radius._50, padding: 22, shadowColor: '#000', shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.05, shadowRadius: 10, elevation: 3 },
  cardTop: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'flex-start' },
  textContainer: { flex: 1, paddingRight: 15 },
  bigActionButton: { width: 52, height: 52, borderRadius: 26, justifyContent: 'center', alignItems: 'center' },
});

===== app/(auth)/_layout.tsx =====
import { Stack } from 'expo-router';

export default function AuthLayout() {
  return (
    <Stack screenOptions={{ headerShown: false ,animation: 'fade_from_bottom' , animationMatchesGesture: true}}>
      <Stack.Screen name="login"  />
      <Stack.Screen name="register" />
    </Stack>
  );
}

===== app/(auth)/login.tsx =====
import Button from '@/components/Button';
import Input from '@/components/Input';
import ScreenWrapper from '@/components/ScreenWrapper';
import Typo from '@/components/Typo';
import { colors, spacingX, spacingY } from '@/constants/theme';
import { useAuth } from '@/context/AuthContext';
import api from '@/services/api';
import { useRouter } from 'expo-router';
import { LockKey, User } from 'phosphor-react-native';
import React, { useState } from 'react';
import { Alert, KeyboardAvoidingView, Platform, ScrollView, StatusBar, StyleSheet, TouchableOpacity, View } from 'react-native';

export default function LoginScreen() {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [loading, setLoading] = useState(false);
    const { signIn } = useAuth();
    const router = useRouter();

    const handleLogin = async () => {
        if (!username || !password) return Alert.alert('Error', 'Please fill all fields');
        setLoading(true);
        try {
            const res = await api.post('/user/signin', { username, password });
            await signIn(res.data.token);
        } catch (error: any) {
            Alert.alert('Login Failed', error.response?.data?.message || 'Something went wrong');
        } finally {
            setLoading(false);
        }
    };

    return (
        <ScreenWrapper>
            <StatusBar barStyle="light-content" />
            <KeyboardAvoidingView 
                behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                style={{ flex: 1 }}
            >
                <ScrollView 
                    contentContainerStyle={styles.container} 
                    keyboardShouldPersistTaps="handled"
                    showsVerticalScrollIndicator={false}
                >
                    <View style={styles.header}>
                        <Typo size={40} fontWeight="800" color={colors.primary} style={{ marginBottom: 10 }}>Recall</Typo>
                        <Typo size={16} color={colors.neutral400} style={{ textAlign: 'center' }}>Welcome back to your second brain.</Typo>
                    </View>

                    <View style={styles.form}>
                        <Input
                            placeholder="Username"
                            value={username}
                            onChangeText={setUsername}
                            icon={<User size={20} color={colors.neutral500} weight="fill" />}
                        />
                        <Input
                            placeholder="Password"
                            value={password}
                            onChangeText={setPassword}
                            secureTextEntry
                            icon={<LockKey size={20} color={colors.neutral500} weight="fill" />}
                        />
                        
                        <Typo size={14} color={colors.neutral500} fontWeight="600" style={{ alignSelf: 'flex-end', marginBottom: 20 }}>
                            Forgot Password?
                        </Typo>

                        <Button onPress={handleLogin} loading={loading} style={styles.button}>
                            <Typo color={colors.white} fontWeight="bold" size={16}>Login</Typo>
                        </Button>
                    </View>

                    <View style={styles.footer}>
                        <Typo size={15} color={colors.neutral400}>Don't have an account? </Typo>
                        <TouchableOpacity onPress={() => router.push('/(auth)/register')}>
                            <Typo size={15} color={colors.primary} fontWeight="bold">Sign Up</Typo>
                        </TouchableOpacity>
                    </View>
                </ScrollView>
            </KeyboardAvoidingView>
        </ScreenWrapper>
    );
}

const styles = StyleSheet.create({
    container: { flexGrow: 1, justifyContent: 'center', paddingHorizontal: spacingX._20, paddingBottom: 50 },
    header: { alignItems: 'center', marginBottom: spacingY._40 },
    form: { gap: spacingY._15 },
    button: { marginTop: 10 },
    footer: { flexDirection: 'row', justifyContent: 'center', alignItems: 'center', marginTop: spacingY._30 },
});

===== app/(auth)/register.tsx =====
import Button from '@/components/Button';
import Input from '@/components/Input';
import ScreenWrapper from '@/components/ScreenWrapper';
import Typo from '@/components/Typo';
import { colors, spacingX, spacingY } from '@/constants/theme';
import api from '@/services/api';
import { useRouter } from 'expo-router';
import { LockKey, User } from 'phosphor-react-native';
import React, { useState } from 'react';
import { Alert, KeyboardAvoidingView, Platform, ScrollView, StatusBar, StyleSheet, TouchableOpacity, View } from 'react-native';

export default function RegisterScreen() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  const handleRegister = async () => {
    if (!username || !password) return Alert.alert('Hold up', 'Please fill in both fields.');
    if (password.length < 5) return Alert.alert('Invalid Password', 'Password must be at least 5 characters long.');
    
    setLoading(true);
    try {
      await api.post('/user/signup', { username, password });
      Alert.alert('Success', 'Account created! Please log in.', [{ text: 'OK', onPress: () => router.push('/(auth)/login') }]);
    } catch (error: any) {
      Alert.alert('Signup Failed', error.response?.data?.message || 'Something went wrong');
    } finally {
      setLoading(false);
    }
  };

  return (
    <ScreenWrapper>
      <StatusBar barStyle="light-content" />

      <KeyboardAvoidingView 
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
      >
        <ScrollView 
            contentContainerStyle={styles.container} 
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
        >
            <View style={styles.header}>
                <Typo size={32} fontWeight="800" color={colors.white} style={{ marginBottom: 10 }}>Create Account</Typo>
                <Typo size={16} color={colors.neutral400}>Join Recall and start saving memories.</Typo>
            </View>

            <View style={styles.form}>
                <Input 
                    placeholder="Choose a Username" 
                    value={username} 
                    onChangeText={setUsername} 
                    icon={<User size={20} color={colors.neutral500} weight="fill" />}
                    autoCapitalize="none"
                />
                <Input 
                    placeholder="Create a Password (min 5 chars)" 
                    value={password} 
                    onChangeText={setPassword} 
                    secureTextEntry
                    icon={<LockKey size={20} color={colors.neutral500} weight="fill" />}
                />
                <Button onPress={handleRegister} loading={loading} style={styles.button}>
                    <Typo color={colors.white} fontWeight="bold" size={16}>Sign Up</Typo>
                </Button>
            </View>

            <View style={styles.footer}>
                <Typo size={15} color={colors.neutral400}>Already have an account? </Typo>
                <TouchableOpacity onPress={() => router.push('/(auth)/login')}>
                    <Typo size={15} color={colors.primary} fontWeight="bold">Login</Typo>
                </TouchableOpacity>
            </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </ScreenWrapper>
  );
}

const styles = StyleSheet.create({
  container: { flexGrow: 1, justifyContent: 'center', paddingHorizontal: spacingX._20, paddingBottom: 50 },
  header: { marginBottom: spacingY._30 },
  form: { gap: spacingY._15 },
  button: { marginTop: spacingY._10 },
  footer: { flexDirection: 'row', justifyContent: 'center', marginTop: spacingY._30 }
});

===== app/index.tsx =====
// app/index.tsx
import { useAuth } from '@/context/AuthContext';
import { Redirect } from 'expo-router';
import { ActivityIndicator, View } from 'react-native';

export default function Index() {
  const { token, isLoading } = useAuth();

  if (isLoading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" />
      </View>
    );
  }

  return token ? <Redirect href="/(app)/home" /> : <Redirect href="/(auth)/login" />;
}

===== components/Avatar.tsx =====
import { colors, radius } from '@/constants/theme'
import { getAvatarPath } from '@/services/imageService'
import type { AvatarProps } from '@/types'
import { verticalScale } from '@/utils/styling'
import { Image } from 'expo-image'
import React from 'react'
import { StyleSheet, View } from 'react-native'
const Avatar = ({ size = 40, uri, style, isGroup = false }: AvatarProps) => {
  return (
    <View
      style={[
        styles.avatar,
        {
          height: verticalScale(size),
          width: verticalScale(size),
          borderRadius: radius.full,
          borderWidth: 1,
          borderColor: colors.neutral500,
        },
        style,
      ]}
    >
      <Image
        transition={1000}
        source={getAvatarPath(uri, isGroup)}
        contentFit="cover"
        style={{ width: '100%', height: '100%' }}
      />
    </View>
  )
}

export default Avatar

const styles = StyleSheet.create({
  avatar: {
    alignSelf: 'center',
    backgroundColor: colors.neutral200,
    height: verticalScale(47),
    width: verticalScale(47),
    borderRadius: radius.full,
    borderWidth: 1,
    borderColor: colors.neutral100,
    overflow: 'hidden',
  },
})

===== components/BackButton.tsx =====
import { colors } from '@/constants/theme'
import type { BackButtonProps } from '@/types'
import { verticalScale } from '@/utils/styling'
import { useRouter } from 'expo-router'
import { CaretLeftIcon } from 'phosphor-react-native'
import React from 'react'
import { StyleSheet, TouchableOpacity } from 'react-native'

const BackButton = ({
  style,
  iconSize = 30,
  color = colors.white,
}: BackButtonProps) => {
  const router = useRouter()

  console.log(router.canGoBack())

  const backAction = () => {
    if (router.canGoBack()) {
      router.back()
    } else {
      router.replace('/');
    }
  }

    return (
      <TouchableOpacity
        onPress={backAction}
        style={[styles.button, style]}
      >
        <CaretLeftIcon size={verticalScale(iconSize)} color={color} weight="bold" />
      </TouchableOpacity>
    )
  }

  export default BackButton

  const styles = StyleSheet.create({
    button: {
      padding: verticalScale(6),
    },
  })

===== components/Button.tsx =====
import { colors, radius } from '@/constants/theme'
import type { ButtonProps } from '@/types'
import { verticalScale } from '@/utils/styling'
import React from 'react'
import { StyleSheet, TouchableOpacity } from 'react-native'
import Loading from './Loading'

const Button = ({ style, onPress, children, loading = false }: ButtonProps) => {
  return (
    <TouchableOpacity onPress={onPress} style={[styles.button, style]}>
      {!loading ? children : <Loading color={colors.white} />}
    </TouchableOpacity>
  )
}

export default Button

const styles = StyleSheet.create({
  button: {
    backgroundColor: colors.primary,
    borderRadius: radius._90,
    borderCurve: 'continuous',
    height: verticalScale(52), // Match Input Height
    justifyContent: 'center',
    alignItems: 'center',
  },
})

===== components/external-link.tsx =====
import { Href, Link } from 'expo-router';
import { openBrowserAsync, WebBrowserPresentationStyle } from 'expo-web-browser';
import { type ComponentProps } from 'react';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: Href & string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (process.env.EXPO_OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href, {
            presentationStyle: WebBrowserPresentationStyle.AUTOMATIC,
          });
        }
      }}
    />
  );
}

===== components/haptic-tab.tsx =====
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}

===== components/Header.tsx =====
import { colors, radius, spacingX, spacingY } from '@/constants/theme';
import React from 'react';
import { Platform, StyleSheet, View } from 'react-native';
import BackButton from './BackButton';
import Typo from './Typo';

interface HeaderProps {
  title?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  showBackButton?: boolean;
  children?: React.ReactNode;
  style?: any; // Allow overriding height
}

const Header = ({ title, leftIcon, rightIcon, showBackButton = true, children, style }: HeaderProps) => {
  return (
    <View style={[styles.container, style]}>
      
      <View style={styles.topRow}>
        <View style={styles.iconContainer}>
          {leftIcon ? leftIcon : showBackButton ? <BackButton color={colors.white} /> : null}
        </View>

        {title && (
          <Typo size={26} fontWeight={'bold'} color={colors.white} style={styles.title}>
            {title}
          </Typo>
        )}

        <View style={styles.iconContainer}>
          {rightIcon}
        </View>
      </View>

      {children && (
        <View style={styles.bottomRow}>
          {children}
        </View>
      )}

    </View>
  );
};

export default Header;

const styles = StyleSheet.create({
  container: {
    backgroundColor: colors.primary,
    paddingTop: Platform.OS === 'ios' ? 70 : 60,
    paddingBottom: spacingY._20,
    paddingHorizontal: spacingX._10,
    borderBottomLeftRadius: radius._30,
    borderBottomRightRadius: radius._30,
    position: 'absolute',
    top: 0, left: 0, right: 0,
    zIndex: 100,
  },
  topRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 10, // Spacing between title and search bar
  },
  bottomRow: {
    paddingTop: 5,
  },
  title: {
    textAlign: 'center',
    flex: 1,
  },
  iconContainer: {
    zIndex: 20,
    minWidth: 40,
    alignItems: 'center',
    justifyContent: 'center',
  },
});

===== components/Input.tsx =====
import { colors, radius, spacingX } from '@/constants/theme'
import type { InputProps } from '@/types'
import { verticalScale } from '@/utils/styling'
import React, { useState } from 'react'
import { StyleSheet, TextInput, View } from 'react-native'

const Input = (props: InputProps) => {
  const [focused, setFocused] = useState(false)

  return (
    <View
      style={[
        styles.container,
        props.containerStyle,
        focused && styles.primaryBorder,
      ]}
    >
      {props.icon && props.icon}
      <TextInput
        style={[styles.input, props.inputStyle]}
        // Default to light text (for dark mode) unless overridden
        placeholderTextColor={props.placeholderTextColor || colors.neutral500}
        ref={props.inputRef && props.inputRef}
        onFocus={() => setFocused(true)}
        onBlur={() => setFocused(false)}
        {...props}
      />
    </View>
  )
}

export default Input

const styles = StyleSheet.create({
  container: {
    flexDirection: "row",
    height: verticalScale(52), // Standardized Height
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
    borderColor: colors.darkInput,
    borderRadius: radius._90,
    borderCurve: 'continuous',
    paddingHorizontal: spacingX._15,
    backgroundColor: colors.darkInput, // Default to Dark
    gap: spacingX._10,
  },
  primaryBorder: {
    borderColor: colors.primary, // Highlight on focus
  },
  input: {
    flex: 1,
    color: colors.textLight, // Default to White Text
    fontSize: verticalScale(14),
  },
})

===== components/Loading.tsx =====
import { colors } from '@/constants/theme'
import React from 'react'
import {
  ActivityIndicator,
  StyleSheet,
  View,
  type ActivityIndicatorProps
} from 'react-native'

const Loading = ({
  size = 'large',
  color = colors.primaryDark,
}: ActivityIndicatorProps) => {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <ActivityIndicator color={color} size={size} />
    </View>
  )
}

export default Loading

const styles = StyleSheet.create({})

===== components/ScreenWrapper.tsx =====
import { colors } from '@/constants/theme'
import type { ScreenWrapperProps } from '@/types'
import React from 'react'
import {
  Dimensions,
  Platform,
  StatusBar,
  View
} from 'react-native'

const { height } = Dimensions.get('window')

const ScreenWrapper = ({
  style,
  children,
  parentStyle,
  barStyle = 'light',
  isModal = false,
}: ScreenWrapperProps) => {
  const nativeBarStyle = barStyle === 'dark' ? 'dark-content' : 'light-content'
  let paddingTop = Platform.OS == 'ios' ? height * 0.06 : 40
  let paddingBottom = 0
  if (isModal) {
    paddingTop = Platform.OS == 'ios' ? height * 0.02 : 45
    paddingBottom = height * 0.02
  }

  return (
    <View
      style={[
        {
          flex: 1,
          backgroundColor: colors.black ,
          paddingBottom,
          paddingTop,
        },
        style,
      ]}
    >
        <StatusBar barStyle={nativeBarStyle} backgroundColor={'transparent'} />
        {children}
    </View>
  )
}

export default ScreenWrapper

===== components/SkeletonCard.tsx =====
import { colors, radius, spacingX, spacingY } from '@/constants/theme';
import React, { useEffect, useRef } from 'react';
import { Animated, StyleSheet, View } from 'react-native';

export default function SkeletonCard() {
  const opacity = useRef(new Animated.Value(0.3)).current;

  useEffect(() => {
    // Create a loop that fades the skeleton in and out
    Animated.loop(
      Animated.sequence([
        Animated.timing(opacity, { toValue: 1, duration: 1000, useNativeDriver: true }),
        Animated.timing(opacity, { toValue: 0.3, duration: 1000, useNativeDriver: true }),
      ])
    ).start();
  }, []);

  return (
    <Animated.View style={[styles.card, { opacity }]}>
      {/* Fake Title Line */}
      <View style={styles.titlePlaceholder} />
      
      {/* Fake Description Lines */}
      <View style={styles.descPlaceholder} />
      <View style={[styles.descPlaceholder, { width: '60%' }]} />

      {/* Fake Bottom Buttons */}
      <View style={styles.bottomRow}>
        <View style={styles.pill} />
        <View style={styles.pill} />
      </View>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: colors.white,
    padding: spacingX._20,
    borderRadius: radius._40,
    marginBottom: spacingY._15,
    height: 180, // Approximate height of your real cards
    justifyContent: 'center',
  },
  titlePlaceholder: {
    height: 24,
    width: '50%',
    backgroundColor: colors.neutral200,
    borderRadius: 4,
    marginBottom: 20,
  },
  descPlaceholder: {
    height: 14,
    width: '90%',
    backgroundColor: colors.neutral100,
    borderRadius: 4,
    marginBottom: 10,
  },
  bottomRow: {
    flexDirection: 'row',
    gap: 10,
    marginTop: 20,
  },
  pill: {
    width: 60,
    height: 30,
    backgroundColor: colors.neutral200,
    borderRadius: 15,
  }
});

===== components/TextArea.tsx =====
import { colors, radius, spacingX, spacingY } from '@/constants/theme'
import type { InputProps } from '@/types'
import { verticalScale } from '@/utils/styling'
import React, { useState } from 'react'
import { StyleSheet, TextInput, View } from 'react-native'

const TextArea = (props: InputProps) => {
  const [focused, setFocused] = useState(false)

  return (
    <View
      style={[
        styles.container,
        props.containerStyle,
        focused && styles.primaryBorder,
      ]}
    >
      <TextInput
        multiline={true}
        numberOfLines={4}
        style={[styles.input, props.inputStyle]}
        placeholderTextColor={props.placeholderTextColor || colors.neutral500}
        ref={props.inputRef && props.inputRef}
        onFocus={() => setFocused(true)}
        onBlur={() => setFocused(false)}
        {...props}
      />
    </View>
  )
}

export default TextArea

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    height: verticalScale(100),
    borderWidth: 1,
    borderColor: colors.darkInput,
    borderRadius: radius._15, // Standardized Radius
    borderCurve: 'continuous',
    paddingVertical: spacingY._15,
    paddingHorizontal: spacingX._15,
    backgroundColor: colors.darkInput, // Default to Dark
    gap: spacingX._10,
  },
  primaryBorder: {
    borderColor: colors.primary,
  },
  input: {
    flex: 1,
    color: colors.textLight, // Default to White Text
    fontSize: verticalScale(14),
    textAlignVertical: 'top',
  },
})

===== components/Typo.tsx =====
import { colors } from '@/constants/theme'
import type { TypoProps } from '@/types'
import { verticalScale } from '@/utils/styling'
import React from 'react'
import { Text, type TextStyle } from 'react-native'

const Typo = ({
  size = 16,
  color = colors.text,
  fontWeight = '400',
  children,
  style,
  textProps = {},
}: TypoProps) => {
  const textStyle: TextStyle = {
    fontSize: verticalScale(size),
    color,
    fontWeight,
  }
  return (
    <Text style={[textStyle, style]} {...textProps}>
      {children}
    </Text>
  )
}

export default Typo

===== constants/theme.ts =====
import { scale, verticalScale } from "@/utils/styling";

// Base colors that don't change
const palette = {
  primary: "#E64A19",
  primaryLight: "#FFCCBC",
  primaryDark: "#D84315",
  white: "#ffffff",
  black: "#000000",
  rose: "#ef4444",
  neutral100: "#f5f5f4",
  neutral200: "#e7e5e4",
  neutral400: "#a8a29e",
  neutral500: "#78716c",
  neutral600: "#57534e",
};

export const colors = {
  ...palette,
  light: {
    background: "#f2f2f2",
    card: "#ffffff",
    text: "#1f2937",
    textLight: "#78716c", // Grayish text for descriptions
    inputBg: palette.neutral100,
    inputBorder: palette.neutral200,
    icon: palette.black,
  },
  dark: {
    background: "#000000",
    card: "#111111",
    text: "#F5F5F5",
    textLight: "#a8a29e", // Lighter gray for dark mode
    inputBg: "#1C1C1C",
    inputBorder: "#1C1C1C",
    icon: "#F5F5F5",
  },
};

export const spacingX = {
  _3: scale(3),
  _5: scale(5),
  _7: scale(7),
  _10: scale(10),
  _12: scale(12),
  _15: scale(15),
  _20: scale(20),
  _25: scale(25),
  _30: scale(30),
  _35: scale(35),
  _40: scale(40),
};

export const spacingY = {
  _5: verticalScale(5),
  _7: verticalScale(7),
  _10: verticalScale(10),
  _12: verticalScale(12),
  _15: verticalScale(15),
  _17: verticalScale(17),
  _20: verticalScale(20),
  _25: verticalScale(25),
  _30: verticalScale(30),
  _35: verticalScale(35),
  _40: verticalScale(40),
  _50: verticalScale(50),
  _60: verticalScale(60),
};

export const radius = {
  _3: verticalScale(3),
  _6: verticalScale(6),
  _10: verticalScale(10),
  _12: verticalScale(12),
  _15: verticalScale(15),
  _17: verticalScale(17),
  _20: verticalScale(20),
  _30: verticalScale(30),
  _40: verticalScale(40),
  _50: verticalScale(50),
  _60: verticalScale(60),
  _70: verticalScale(70),
  _80: verticalScale(80),
  _90: verticalScale(90),
  full: 200,
};

export const HEADER_HEIGHT = 140;
export const HEADER_HEIGHT_EXPANDED = 190;

===== context/AuthContext.tsx =====
import { useRouter, useSegments } from 'expo-router';
import * as SecureStore from 'expo-secure-store';
import React, { createContext, useContext, useEffect, useState } from 'react';

interface AuthContextType {
  token: string | null;
  isLoading: boolean;
  signIn: (token: string) => Promise<void>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [token, setToken] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const segments = useSegments();
  const router = useRouter();

  useEffect(() => {
    const loadToken = async () => {
      try {
        const storedToken = await SecureStore.getItemAsync('token');
        if (storedToken) setToken(storedToken);
      } catch (e) {
        console.error('Failed to load token', e);
      } finally {
        setIsLoading(false);
      }
    };
    loadToken();
  }, []);

  useEffect(() => {
    if (isLoading) return;

    const inAuthGroup = segments[0] === '(auth)';
    const inAppGroup = segments[0] === '(app)';
    const isIndexRoute = segments.length === 0;

    // Only redirect if not already on the correct route and not on index
    if (!token && !inAuthGroup && !isIndexRoute) {
      router.replace('/(auth)/login');
    } else if (token && inAuthGroup) {
      router.replace('/(app)/home');
    }
  }, [token, segments, isLoading]);

  const signIn = async (newToken: string) => {
    await SecureStore.setItemAsync('token', newToken);
    setToken(newToken);
  };

  const signOut = async () => {
    await SecureStore.deleteItemAsync('token');
    setToken(null);
  };

  return (
    <AuthContext.Provider value={{ token, isLoading, signIn, signOut }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext) as AuthContextType;

===== context/ThemeContext.tsx =====
import { colors } from '@/constants/theme';
import AsyncStorage from '@react-native-async-storage/async-storage';
import React, { createContext, useContext, useEffect, useState } from 'react';
import { useColorScheme as useSystemColorScheme } from 'react-native';

type ThemeMode = 'light' | 'dark' | 'system';

interface ThemeContextType {
  theme: 'light' | 'dark';
  mode: ThemeMode;
  setMode: (mode: ThemeMode) => void;
  toggleTheme: () => void; // Simple toggle for UI
  activeColors: typeof colors.light;
}

const ThemeContext = createContext<ThemeContextType | null>(null);

export const ThemeProvider = ({ children }: { children: React.ReactNode }) => {
  const systemScheme = useSystemColorScheme();
  const [mode, setMode] = useState<ThemeMode>('system');
  
  // Determine actual theme (light/dark) based on mode
  const activeTheme = mode === 'system' ? (systemScheme || 'light') : mode;

  useEffect(() => {
    loadTheme();
  }, []);

  const loadTheme = async () => {
    try {
      const storedMode = await AsyncStorage.getItem('themeMode');
      if (storedMode) setMode(storedMode as ThemeMode);
    } catch (e) {
      console.log('Failed to load theme', e);
    }
  };

  const updateMode = async (newMode: ThemeMode) => {
    setMode(newMode);
    await AsyncStorage.setItem('themeMode', newMode);
  };

  const toggleTheme = async () => {
    const nextMode = activeTheme === 'light' ? 'dark' : 'light';
    await updateMode(nextMode);
  };

  return (
    <ThemeContext.Provider value={{
      theme: activeTheme,
      mode,
      setMode: updateMode,
      toggleTheme,
      activeColors: colors[activeTheme]
    }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) throw new Error('useTheme must be used within a ThemeProvider');
  return context;
};

===== hooks/use-color-scheme.ts =====
export { useColorScheme } from 'react-native';

===== hooks/use-color-scheme.web.ts =====
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}

===== hooks/use-theme-color.ts =====
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

===== services/api.ts =====
import axios from "axios";
import * as SecureStore from "expo-secure-store";
import { Platform } from "react-native";

// 1. Define the correct Production URL (Must include /api/v1)
const PROD_URL = "https://recall-st2b.onrender.com/api/v1";

// 2. Define Local URL for testing
const DEV_URL =
  Platform.OS === "android"
    ? "http://10.0.2.2:5000/api/v1"
    : "http://localhost:5000/api/v1";

// 3. Toggle this variable to switch modes
const IS_PROD = true; // Set to TRUE to use Render backend

const api = axios.create({
  baseURL: IS_PROD ? PROD_URL : DEV_URL,
  headers: {
    "Content-Type": "application/json",
  },
});

// Add this interceptor to DEBUG exactly what URL is failing
api.interceptors.request.use(async (config) => {
  const token = await SecureStore.getItemAsync("token");
  if (token) {
    config.headers.Authorization = token;
  }

  // LOG THE URL to your terminal so you can see if it's correct
  console.log(
    `[Request] ${config.method?.toUpperCase()} ${config.baseURL}${config.url}`,
  );

  return config;
});

export default api;

===== types/index.ts =====
import { ReactNode, RefObject } from "react";
import {
  StyleProp,
  TextInput,
  TextInputProps,
  TextProps,
  TextStyle,
  ViewStyle,
} from "react-native";

export interface AvatarProps {
  size?: number;
  uri?: string;
  style?: StyleProp<ViewStyle>;
  isGroup?: boolean;
}

export interface BackButtonProps {
  style?: StyleProp<ViewStyle>;
  iconSize?: number;
  color?: string;
}

export interface ButtonProps {
  style?: StyleProp<ViewStyle>;
  onPress?: () => void;
  children: ReactNode;
  loading?: boolean;
}

export interface HeaderProps {
  title?: string;
  leftIcon?: ReactNode;
  rightIcon?: ReactNode;
  style?: StyleProp<ViewStyle>;
}

export interface InputProps extends TextInputProps {
  containerStyle?: StyleProp<ViewStyle>;
  inputStyle?: StyleProp<TextStyle>;
  icon?: ReactNode;
  inputRef?: RefObject<TextInput>;
}

export interface ScreenWrapperProps {
  style?: StyleProp<ViewStyle>;
  children: ReactNode;
  showPattern?: boolean;
  parentStyle?: StyleProp<ViewStyle>;
  barStyle?: "light" | "dark";
  isModal?: boolean;
  bgOpacity?: number;
}

export interface TypoProps {
  size?: number;
  color?: string;
  fontWeight?: TextStyle["fontWeight"];
  children: ReactNode;
  style?: StyleProp<TextStyle>;
  textProps?: TextProps;
}

===== utils/styling.ts =====
import { Dimensions, PixelRatio } from "react-native";

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get("window");

const [shortDimension, longDimension] =
  SCREEN_WIDTH < SCREEN_HEIGHT
    ? [SCREEN_WIDTH, SCREEN_HEIGHT]
    : [SCREEN_HEIGHT, SCREEN_WIDTH];

const guidelineBaseWidth = 375;
const guidelineBaseHeight = 812;

export const scale = (size: number) =>
  Math.round(
    PixelRatio.roundToNearestPixel(
      (shortDimension / guidelineBaseWidth) * size,
    ),
  );

export const verticalScale = (size: number) =>
  Math.round(
    PixelRatio.roundToNearestPixel(
      (longDimension / guidelineBaseHeight) * size,
    ),
  );
